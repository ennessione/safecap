(* This file is generated by Why3's S-expression driver *)
theory Task
  Assoc ::= ((= (+ (+ ^int ^int) ^int) (+ ^int (+ ^int ^int)))) ([ forall x:
                                                                    int, y:
                                                                    int, z:
                                                                    int.
                                                                    ((x + y) +
                                                                    z) =
                                                                    (x +
                                                                    (y + z)) ])

Unit_def_l ::= ((= (+ zero ^int) ^int)) ([ 
  forall x:int. (zero + x) = x ])

Unit_def_r ::= ((= (+ ^int zero) ^int)) ([ 
  forall x:int. (x + zero) = x ])

Inv_def_l ::= ((= (+ (- ^int) ^int) zero)) ([ 
  forall x:int. ((- x) + x) = zero ])

Inv_def_r ::= ((= (+ ^int (- ^int)) zero)) ([ 
  forall x:int. (x + (- x)) = zero ])

Comm ::= ((= (+ ^int ^int) (+ ^int ^int))) ([ 
  forall x:int, y:int. (x + y) = (y + x) ])

Assoc1 ::= ((= (* (* ^int ^int) ^int) (* ^int (* ^int ^int)))) ([ 
  forall x:int, y:int, z:int. ((x * y) * z) = (x * (y * z)) ])

Mul_distr_l ::= ((= (* ^int (+ ^int ^int)) (+ (* ^int ^int) (* ^int ^int)))) ([ 
  forall x:int, y:int, z:int. (x * (y + z)) = ((x * y) + (x * z)) ])

Mul_distr_r ::= ((= (* (+ ^int ^int) ^int) (+ (* ^int ^int) (* ^int ^int)))) ([ 
  forall x:int, y:int, z:int. ((y + z) * x) = ((y * x) + (z * x)) ])

Comm1 ::= ((= (* ^int ^int) (* ^int ^int))) ([ 
  forall x:int, y:int. (x * y) = (y * x) ])

Unitary ::= ((= (* one ^int) ^int)) ([ 
  forall x:int. (one * x) = x ])

NonTrivialRing ::= (not (= zero one)) ([ not 
  zero = one ])

Refl ::= ((<= ^int ^int)) ([ forall x:int. x <= x ])

Trans ::= ((-> (<= ^int ^int) (-> (<= ^int ^int) (<= ^int ^int)))) ([ 
  forall x:int, y:int, z:int. x <= y -> y <= z -> x <= z ])

Antisymm ::= ((-> (<= ^int ^int) (-> (<= ^int ^int) (= ^int ^int)))) ([ 
  forall x:int, y:int. x <= y -> y <= x -> x = y ])

Total ::= ((\/ (<= ^int ^int) (<= ^int ^int))) ([ 
  forall x:int, y:int. x <= y \/ y <= x ])

ZeroLessOne ::= (<= zero one) ([ 
  zero <= one ])

CompatOrderAdd ::= ((-> (<= ^int ^int) (<= (+ ^int ^int) (+ ^int ^int)))) ([ 
  forall x:int, y:int, z:int. x <= y -> (x + z) <= (y + z) ])

CompatOrderMult ::= ((-> (<= ^int ^int) (-> (<= zero ^int) (<= (* ^int ^int) (* ^int ^int))))) ([ 
  forall x:int, y:int, z:int. x <= y -> zero <= z -> (x * z) <= (y * z) ])

Abs_le ::= ((<-> (<= (abs ^int) ^int) (/\ (<= (- ^int) ^int) (<= ^int ^int)))) ([ 
  forall x:int, y:int. abs x <= y <-> (- y) <= x /\ x <= y ])

Abs_pos ::= ((>= (abs ^int) 0)) ([ 
  forall x:int. abs x >= 0 ])

Div_mod ::= ((-> (not (= ^int 0)) (= ^int (+ (* ^int (div ^int ^int)) (mod ^int ^int))))) ([ 
  forall x:int, y:int. not y = 0 -> x = ((y * div x y) + mod x y) ])

Div_bound ::= ((-> (/\ (>= ^int 0) (> ^int 0)) (/\ (<= 0 (div ^int ^int)) (<= (div ^int ^int) ^int)))) ([ 
  forall x:int, y:int. x >= 0 /\ y > 0 -> 0 <= div x y /\ div x y <= x ])

Mod_bound ::= ((-> (not (= ^int 0)) (/\ (<= 0 (mod ^int ^int)) (< (mod ^int ^int) (abs ^int))))) ([ 
  forall x:int, y:int. not y = 0 -> 0 <= mod x y /\ mod x y < abs y ])

equality_def1 ::= ((-> (== ^(set 'a) ^(set 'a)) (= ^(set 'a) ^(set 'a)))) ([ 
  forall s1:set 'a, s2:set 'a. s1 == s2 -> s1 = s2 ])

subset_def1 ::= ((subset ^(set 'a) ^(set 'a))) ([ 
  forall s:set 'a. subset s s ])

subset_def2 ::= ((-> (subset ^(set 'a) ^(set 'a)) (-> (subset ^(set 'a) ^(set 'a)) (subset ^(set 'a) ^(set 'a))))) ([ 
  forall s1:set 'a, s2:set 'a, s3:set 'a.
   subset s1 s2 -> subset s2 s3 -> subset s1 s3 ])

empty_def1 ::= (is_empty empty) ([ 
  is_empty (empty:set 'a) ])

add_def1 ::= (((<-> (mem ^'a (add ^'a ^(set 'a))) (\/ (= ^'a ^'a) (mem ^'a ^(set 'a)))))) ([ 
  forall x:'a, y:'a. forall s:set 'a. mem x (add y s) <-> x = y \/ mem x s ])

remove_def1 ::= ((<-> (mem ^'a (remove ^'a ^(set 'a))) (/\ (not (= ^'a ^'a)) (mem ^'a ^(set 'a))))) ([ 
  forall x:'a, y:'a, s:set 'a. mem x (remove y s) <-> not x = y /\ mem x s ])

union_def1 ::= ((<-> (mem ^'a (union ^(set 'a) ^(set 'a))) (\/ (mem ^'a ^(set 'a)) (mem ^'a ^(set 'a))))) ([ 
  forall s1:set 'a, s2:set 'a, x:'a.
   mem x (union s1 s2) <-> mem x s1 \/ mem x s2 ])

intersection_def1 ::= ((<-> (mem ^'a (inter ^(set 'a) ^(set 'a))) (/\ (mem ^'a ^(set 'a)) (mem ^'a ^(set 'a))))) ([ 
  forall s1:set 'a, s2:set 'a, x:'a.
   mem x (inter s1 s2) <-> mem x s1 /\ mem x s2 ])

difference_def1 ::= ((<-> (mem ^'a (diff ^(set 'a) ^(set 'a))) (/\ (mem ^'a ^(set 'a)) (not (mem ^'a ^(set 'a)))))) ([ 
  forall s1:set 'a, s2:set 'a, x:'a.
   mem x (diff s1 s2) <-> mem x s1 /\ not mem x s2 ])

integer_def1 ::= ((mem ^int integer)) ([ 
  forall x:int. mem x integer ])

natural_def1 ::= ((<-> (mem ^int natural) (>= ^int 0))) ([ 
  forall x:int. mem x natural <-> x >= 0 ])

interval_def1 ::= ((<-> (mem ^int (mk ^int ^int)) (/\ (<= ^int ^int) (<= ^int ^int)))) ([ 
  forall x:int, a:int, b:int [mem x (mk a b)].
   mem x (mk a b) <-> a <= x /\ x <= b ])

interval_def2 ::= ((-> (> ^int ^int) (= (mk ^int ^int) empty))) ([ 
  forall a:int, b:int. a > b -> mk a b = (empty:set int) ])

interval_def3 ::= ((-> (<= ^int ^int) (= (mk ^int ^int) (add ^int (mk ^int (- ^int 1)))))) ([ 
  forall a:int, b:int. a <= b -> mk a b = add b (mk a (b - 1)) ])

power_def1 ::= ((<-> (mem ^(set 'a) (pow ^(set 'a))) (subset ^(set 'a) ^(set 'a)))) ([ 
  forall x:set 'a, y:set 'a [mem x (pow y)]. mem x (pow y) <-> subset x y ])

image_def1 ::= ((<-> (mem ^'b (image ^(set (, 'a 'b)) ^(set 'a))) ((/\ (mem ^'a ^(set 'a)) (mem (^'a, ^'b) ^(set (, 'a 'b))))))) ([ 
  forall r:set ('a, 'b), dom:set 'a, y:'b [mem y (image r dom)].
   mem y (image r dom) <-> (exists x:'a. mem x dom /\ mem (x, y) r) ])

inverse_def1 ::= (((<-> (mem (^'b, ^'a) (inverse ^(set (, 'a 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b)))))) ([ 
  forall r:set ('a, 'b).
   forall x:'a, y:'b. mem (y, x) (inverse r) <-> mem (x, y) r ])

dom_def1 ::= (((<-> (mem ^'a (dom ^(set (, 'a 'b)))) ((mem (^'a, ^'b) ^(set (, 'a 'b))))))) ([ 
  forall r:set ('a, 'b).
   forall x:'a. mem x (dom r) <-> (exists y:'b. mem (x, y) r) ])

ran_def ::= (((<-> (mem ^'b (ran ^(set (, 'a 'b)))) ((mem (^'a, ^'b) ^(set (, 'a 'b))))))) ([ 
  forall r:set ('a, 'b).
   forall y:'b. mem y (ran r) <-> (exists x:'a. mem (x, y) r) ])

partialfunction_def1 ::= ((<-> (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (/\ ((-> (mem (^'a, ^'b) ^(set (, 'a 'b))) (/\ (mem ^'a ^(set 'a)) (mem ^'b ^(set 'b))))) ((-> (/\ (mem (^'a, ^'b) ^(set (, 'a 'b))) (mem (^'a, ^'b) ^(set (, 'a 'b)))) (= ^'b ^'b)))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s +-> t) <->
    (forall x:'a, y:'b. mem (x, y) f -> mem x s /\ mem y t) /\
     (forall x:'a, y1:'b, y2:'b. mem (x, y1) f /\ mem (x, y2) f -> y1 = y2) ])

totalfunction_def1 ::= ((<-> (mem ^(set (, 'a 'b)) (--> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (== (dom ^(set (, 'a 'b))) ^(set 'a))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s --> t) <-> mem f (s +-> t) /\ dom f == s ])

apply_def1 ::= ((-> (/\ (mem ^'a ^(set 'a)) (mem ^(set (, 'a 'b)) (--> ^(set 'a) ^(set 'b)))) (mem (^'a, (apply ^(set (, 'a 'b)) ^'a)) ^(set (, 'a 'b))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b, a:'a.
   mem a s /\ mem f (s --> t) -> mem (a, apply f a) f ])

apply_def2 ::= ((-> (/\ (mem ^(set (, 'a 'b)) (--> ^(set 'a) ^(set 'b))) (mem (^'a, ^'b) ^(set (, 'a 'b)))) (= ^'b (apply ^(set (, 'a 'b)) ^'a)))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b, a:'a, b:'b.
   mem f (s --> t) /\ mem (a, b) f -> b = apply f a ])

apply_def3 ::= (((-> (mem ^(set (, 'a 'b)) (--> ^(set 'a) ^(set 'b))) (-> (mem (inverse ^(set (, 'a 'b))) (+-> ^(set 'b) ^(set 'a))) (-> (mem ^'a ^(set 'a)) (-> (mem ^'a ^(set 'a)) (-> (= (apply ^(set (, 'a 'b)) ^'a) (apply ^(set (, 'a 'b)) ^'a)) (= ^'a ^'a)))))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   forall x:'a, y:'a.
    mem f (s --> t) ->
     mem (inverse f) (t +-> s) ->
      mem x s -> mem y s -> apply f x = apply f y -> x = y ])

times_def1 ::= ((<-> (mem (^'a, ^'b) (times ^(set 'a) ^(set 'b))) (/\ (mem ^'a ^(set 'a)) (mem ^'b ^(set 'b))))) ([ 
  forall a:set 'a, b:set 'b, x:'a, y:'b.
   mem (x, y) (times a b) <-> mem x a /\ mem y b ])

cprod_def1 ::= ((<-> (mem (^'a, ^'b) (cprod ^(set 'a) ^(set 'b))) (/\ (mem ^'a ^(set 'a)) (mem ^'b ^(set 'b))))) ([ 
  forall x:'a, y:'b, s:set 'a, t:set 'b.
   mem (x, y) (cprod s t) <-> mem x s /\ mem y t ])

cprod_def2 ::= ((<-> (mem (^'a, ^'b) (cprod ^(set 'a) empty)) (mem (^'a, ^'b) empty))) ([ 
  forall x:'a, y:'b, s:set 'a.
   mem (x, y) (cprod s (empty:set 'b)) <-> mem (x, y) (empty:set ('a, 'b)) ])

dprod_def1 ::= ((<-> (mem (^'a, (^'b, ^'c)) (dprod ^(set (, 'a 'b)) ^(set (, 'a 'c)))) (/\ (mem (^'a, ^'b) ^(set (, 'a 'b))) (mem (^'a, ^'c) ^(set (, 'a 'c)))))) ([ 
  forall s:set ('a, 'b), t:set ('a, 'c), x:'a, y:'b, z:'c.
   mem (x, (y, z)) (dprod s t) <-> mem (x, y) s /\ mem (x, z) t ])

pprod_def1 ::= ((<-> (mem ((^'a, ^'b), (^'c, ^'d)) (pprod ^(set (, 'a 'c)) ^(set (, 'b 'd)))) (/\ (mem (^'a, ^'c) ^(set (, 'a 'c))) (mem (^'b, ^'d) ^(set (, 'b 'd)))))) ([ 
  forall p:set ('a, 'c), q:set ('b, 'd), x:'a, y:'b, m:'c, n:'d.
   mem ((x, y), (m, n)) (pprod p q) <-> mem (x, m) p /\ mem (y, n) q ])

trel_def1 ::= ((-> (mem ^(set (, 'a 'b)) (<<-> ^(set 'a) ^(set 'b))) (= (dom ^(set (, 'a 'b))) ^(set 'a)))) ([ 
  forall r:set ('a, 'b), s:set 'a, t:set 'b. mem r (s <<-> t) -> dom r = s ])

srel_def1 ::= ((-> (mem ^(set (, 'a 'b)) (<->> ^(set 'a) ^(set 'b))) (= (ran ^(set (, 'a 'b))) ^(set 'b)))) ([ 
  forall r:set ('a, 'b), s:set 'a, t:set 'b. mem r (s <->> t) -> ran r = t ])

tsrel_def1 ::= ((-> (mem ^(set (, 'a 'b)) (<<->> ^(set 'a) ^(set 'b))) (/\ (= (dom ^(set (, 'a 'b))) ^(set 'a)) (= (ran ^(set (, 'a 'b))) ^(set 'b))))) ([ 
  forall r:set ('a, 'b), t:set 'b, s:set 'a.
   mem r (s <<->> t) -> dom r = s /\ ran r = t ])

pinj_def1 ::= ((<-> (mem ^(set (, 'a 'b)) (>+> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (mem (inverse ^(set (, 'a 'b))) (+-> ^(set 'b) ^(set 'a)))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s >+> t) <-> mem f (s +-> t) /\ mem (inverse f) (t +-> s) ])

psur_def1 ::= ((<-> (mem ^(set (, 'a 'b)) (+->> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (= (ran ^(set (, 'a 'b))) ^(set 'b))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s +->> t) <-> mem f (s +-> t) /\ ran f = t ])

tinj_def ::= ((<-> (mem ^(set (, 'a 'b)) (>-> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (>+> ^(set 'a) ^(set 'b))) (= (dom ^(set (, 'a 'b))) ^(set 'a))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s >-> t) <-> mem f (s >+> t) /\ dom f = s ])

tinj_def2 ::= ((<-> (mem ^(set (, 'a 'b)) (>-> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (/\ (mem (inverse ^(set (, 'a 'b))) (+-> ^(set 'b) ^(set 'a))) (= (dom ^(set (, 'a 'b))) ^(set 'a)))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s >-> t) <->
    mem f (s +-> t) /\ mem (inverse f) (t +-> s) /\ dom f = s ])

tsur_def1 ::= ((<-> (mem ^(set (, 'a 'b)) (-->> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (--> ^(set 'a) ^(set 'b))) (= (ran ^(set (, 'a 'b))) ^(set 'b))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s -->> t) <-> mem f (s --> t) /\ ran f = t ])

tsurj_def2 ::= ((<-> (mem ^(set (, 'a 'b)) (-->> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (/\ (= (dom ^(set (, 'a 'b))) ^(set 'a)) (= (ran ^(set (, 'a 'b))) ^(set 'b)))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s -->> t) <-> mem f (s +-> t) /\ dom f = s /\ ran f = t ])

bij_def1 ::= ((<-> (mem ^(set (, 'a 'b)) (>->> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (>-> ^(set 'a) ^(set 'b))) (mem ^(set (, 'a 'b)) (-->> ^(set 'a) ^(set 'b)))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s >->> t) <-> mem f (s >-> t) /\ mem f (s -->> t) ])

bij_def2 ::= ((-> (mem ^(set (, 'a 'b)) (>->> ^(set 'a) ^(set 'b))) (/\ (mem ^(set (, 'a 'b)) (>+> ^(set 'a) ^(set 'b))) (/\ (mem (inverse ^(set (, 'a 'b))) (>+> ^(set 'b) ^(set 'a))) (/\ (= (dom ^(set (, 'a 'b))) ^(set 'a)) (= (ran ^(set (, 'a 'b))) ^(set 'b))))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b.
   mem f (s >->> t) ->
    mem f (s >+> t) /\ mem (inverse f) (t >+> s) /\ dom f = s /\ ran f = t ])

fcomp_def1 ::= ((<-> (mem (^'a, ^'c) (fcomp ^(set (, 'a 'b)) ^(set (, 'b 'c)))) ((/\ (mem (^'a, ^'b) ^(set (, 'a 'b))) (mem (^'b, ^'c) ^(set (, 'b 'c))))))) ([ 
  forall f:set ('a, 'b), g:set ('b, 'c), x:'a, y:'c.
   mem (x, y) (fcomp f g) <-> (exists j:'b. mem (x, j) f /\ mem (j, y) g) ])

bcomp_def1 ::= ((<-> (mem (^'a, ^'c) (bcomp ^(set (, 'b 'c)) ^(set (, 'a 'b)))) ((/\ (mem (^'a, ^'b) ^(set (, 'a 'b))) (mem (^'b, ^'c) ^(set (, 'b 'c))))))) ([ 
  forall f:set ('b, 'c), g:set ('a, 'b), x:'a, y:'c.
   mem (x, y) (bcomp f g) <-> (exists j:'b. mem (x, j) g /\ mem (j, y) f) ])

bcomp_def2 ::= ((<-> (mem (^'a, ^'c) (bcomp ^(set (, 'b 'c)) ^(set (, 'a 'b)))) (mem (^'a, ^'c) (fcomp ^(set (, 'a 'b)) ^(set (, 'b 'c)))))) ([ 
  forall f:set ('b, 'c), g:set ('a, 'b), x:'a, y:'c.
   mem (x, y) (bcomp f g) <-> mem (x, y) (fcomp g f) ])

finite_def1 ::= ((-> (= ^(set 'a) empty) (finite ^(set 'a)))) ([ 
  forall s:set 'a. s = (empty:set 'a) -> finite s ])

finite_def2 ::= ((finite (singleton ^'a))) ([ 
  forall x:'a. finite (singleton x) ])

finite_def3 ::= ((-> (/\ (finite ^(set 'a)) (finite ^(set 'a))) (finite (union ^(set 'a) ^(set 'a))))) ([ 
  forall s:set 'a, t:set 'a. finite s /\ finite t -> finite (union s t) ])

min_def1 ::= ((-> (finite ^(set int)) (not (mem (- (min ^(set int)) 1) ^(set int))))) ([ 
  forall s:set int. finite s -> not mem (min s - 1) s ])

min_def2 ::= ((-> (finite ^(set int)) (< (min ^(set int)) (+ (min ^(set int)) 1)))) ([ 
  forall s:set int. finite s -> min s < (min s + 1) ])

min_def3 ::= ((-> (finite ^(set int)) (= (min (singleton ^int)) ^int))) ([ 
  forall s:set int, x:int. finite s -> min (singleton x) = x ])

max_def1 ::= ((-> (finite ^(set int)) (not (mem (+ (max ^(set int)) 1) ^(set int))))) ([ 
  forall s:set int. finite s -> not mem (max s + 1) s ])

max_def2 ::= ((-> (finite ^(set int)) (< (- (max ^(set int)) 1) (max ^(set int))))) ([ 
  forall s:set int. finite s -> (max s - 1) < max s ])

max_def3 ::= ((-> (finite ^(set int)) (= (max (singleton ^int)) ^int))) ([ 
  forall s:set int, x:int. finite s -> max (singleton x) = x ])

mem_power1 ::= ((<-> (mem ^(set 'a) (pow1 ^(set 'a))) (/\ (not (subset empty ^(set 'a))) (subset ^(set 'a) ^(set 'a))))) ([ 
  forall x:set 'a, y:set 'a.
   mem x (pow1 y) <-> not subset (empty:set 'a) x /\ subset x y ])

card_def0 ::= ((-> (finite ^(set 'a)) (>= (card ^(set 'a)) 0))) ([ 
  forall s:set 'a. finite s -> card s >= 0 ])

card_def1 ::= ((-> (/\ (finite ^(set 'a)) (is_empty ^(set 'a))) (= (card ^(set 'a)) 0))) ([ 
  forall s:set 'a. finite s /\ is_empty s -> card s = 0 ])

card_def2 ::= ((= (card (singleton ^'a)) 1)) ([ 
  forall x:'a. card (singleton x) = 1 ])

card_def3 ::= ((-> (/\ (finite ^(set 'a)) (not (mem ^'a ^(set 'a)))) (= (card (add ^'a ^(set 'a))) (+ 1 (card ^(set 'a)))))) ([ 
  forall x:'a, s:set 'a.
   finite s /\ not mem x s -> card (add x s) = (1 + card s) ])

maxset_axm ::= ((-> (maxset ^(set 'a)) (mem ^'a ^(set 'a)))) ([ 
  forall s:set 'a, x:'a. maxset s -> mem x s ])

domRes_def1 ::= ((<-> (mem (^'a, ^'b) (<| ^(set 'a) ^(set (, 'a 'b)))) (/\ (mem ^'a ^(set 'a)) (mem (^'a, ^'b) ^(set (, 'a 'b)))))) ([ 
  forall x:'a, y:'b, s:set 'a, r:set ('a, 'b).
   mem (x, y) (s <| r) <-> mem x s /\ mem (x, y) r ])

domRes_def2 ::= ((-> (mem (^'a, ^'b) (<| ^(set 'a) ^(set (, 'a 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall x:'a, y:'b, s:set 'a, r:set ('a, 'b).
   mem (x, y) (s <| r) -> mem (x, y) r ])

domSub_def1 ::= ((<-> (mem (^'a, ^'b) (<<| ^(set 'a) ^(set (, 'a 'b)))) (/\ (not (mem ^'a ^(set 'a))) (mem (^'a, ^'b) ^(set (, 'a 'b)))))) ([ 
  forall x:'a, y:'b, s:set 'a, r:set ('a, 'b).
   mem (x, y) (s <<| r) <-> not mem x s /\ mem (x, y) r ])

ranRes_def1 ::= ((<-> (mem (^'a, ^'b) (|> ^(set (, 'a 'b)) ^(set 'b))) (/\ (mem ^'b ^(set 'b)) (mem (^'a, ^'b) ^(set (, 'a 'b)))))) ([ 
  forall x:'a, y:'b, t:set 'b, r:set ('a, 'b).
   mem (x, y) (r |> t) <-> mem y t /\ mem (x, y) r ])

rangesub_def1 ::= ((<-> (mem (^'a, ^'b) (|>> ^(set (, 'a 'b)) ^(set 'b))) (/\ (not (mem ^'b ^(set 'b))) (mem (^'a, ^'b) ^(set (, 'a 'b)))))) ([ 
  forall x:'a, y:'b, t:set 'b, r:set ('a, 'b).
   mem (x, y) (r |>> t) <-> not mem y t /\ mem (x, y) r ])

over_def1 ::= ((<-> (mem (^'a, ^'b) (<+ ^(set (, 'a 'b)) ^(set (, 'a 'b)))) (mem (^'a, ^'b) (union ^(set (, 'a 'b)) (<<| (dom ^(set (, 'a 'b))) ^(set (, 'a 'b))))))) ([ 
  forall x:'a, y:'b, r:set ('a, 'b), g:set ('a, 'b).
   mem (x, y) (r <+ g) <-> mem (x, y) (union g (dom g <<| r)) ])

over_def2 ::= ((<-> (mem (^'a, ^'b) (<+ ^(set (, 'a 'b)) ^(set (, 'a 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall r:set ('a, 'b), x:'a, y:'b. mem (x, y) (r <+ r) <-> mem (x, y) r ])

gunion_def1 ::= ((-> (mem ^'a (gunion empty)) (mem ^'a empty))) ([ 
  forall x:'a. mem x (gunion (empty:set (set 'a))) -> mem x (empty:set 'a) ])

gunion_def2 ::= ((-> (/\ (mem ^(set 'a) ^(set (set 'a))) (/\ (mem ^(set 'a) ^(set (set 'a))) (= (card ^(set (set 'a))) 2))) (-> (mem ^'a (gunion ^(set (set 'a)))) (mem ^'a (union ^(set 'a) ^(set 'a)))))) ([ 
  forall t:set 'a, r:set 'a, s:set (set 'a), x:'a.
   mem t s /\ mem r s /\ card s = 2 -> mem x (gunion s) -> mem x (union r t) ])

gunion_def3 ::= ((-> (/\ (= (card ^(set (set 'a))) 1) (mem ^(set 'a) ^(set (set 'a)))) (-> (mem ^'a (gunion ^(set (set 'a)))) (mem ^'a ^(set 'a))))) ([ 
  forall t:set 'a, s:set (set 'a), x:'a.
   card s = 1 /\ mem t s -> mem x (gunion s) -> mem x t ])

ginter_def1 ::= ((-> (mem ^'a (ginter empty)) (mem ^'a empty))) ([ 
  forall x:'a. mem x (ginter (empty:set (set 'a))) -> mem x (empty:set 'a) ])

ginter_def2 ::= ((-> (/\ (mem ^(set 'a) ^(set (set 'a))) (/\ (mem ^(set 'a) ^(set (set 'a))) (= (card ^(set (set 'a))) 2))) (-> (mem ^'a (ginter ^(set (set 'a)))) (mem ^'a (inter ^(set 'a) ^(set 'a)))))) ([ 
  forall t:set 'a, r:set 'a, s:set (set 'a), x:'a.
   mem t s /\ mem r s /\ card s = 2 -> mem x (ginter s) -> mem x (inter r t) ])

partition_def1 ::= ((-> (mem ^'a (partition ^(set 'a) ^(set (set 'a)))) (= (gunion ^(set (set 'a))) ^(set 'a)))) ([ 
  forall s:set 'a, x:set (set 'a), y:'a.
   mem y (partition s x) -> gunion x = s ])

partition_def2 ::= ((-> (mem ^'a (partition ^(set 'a) ^(set (set 'a)))) (is_empty (ginter ^(set (set 'a)))))) ([ 
  forall s:set 'a, x:set (set 'a), y:'a.
   mem y (partition s x) -> is_empty (ginter x) ])

partition_def3 ::= ((-> (mem ^'a (partition ^(set 'a) ^(set (set 'a)))) ((-> (/\ (mem ^(set 'a) ^(set (set 'a))) (/\ (mem ^(set 'a) ^(set (set 'a))) (not (= ^(set 'a) ^(set 'a))))) (= (inter ^(set 'a) ^(set 'a)) ^(set 'a)))))) ([ 
  forall s:set 'a, x:set (set 'a), y:'a.
   mem y (partition s x) ->
    (forall a:set 'a, b:set 'a.
      mem a x /\ mem b x /\ not a = b -> inter a b = s) ])

partition_def4 ::= ((-> (mem ^'a (partition ^(set 'a) ^(set (set 'a)))) ((-> (mem ^(set 'a) ^(set (set 'a))) (subsetprop ^(set 'a) ^(set 'a)))))) ([ 
  forall s:set 'a, x:set (set 'a), y:'a.
   mem y (partition s x) -> (forall q:set 'a. mem q x -> subsetprop q s) ])

comprehension_def ::= (((<-> (mem ^'a (comprehension ^('a -> bool))) (= (@ ^('a -> bool) ^'a) True)))) ([ 
  forall p:'a -> bool.
   forall x:'a. mem x (comprehension p) <-> (p @ x) = True ])

map_def1 ::= (((-> (mem ^'a ^(set 'a)) (mem (@ ^('a -> 'b) ^'a) (map ^('a -> 'b) ^(set 'a)))))) ([ 
  forall f:'a -> 'b, u:set 'a. forall x:'a. mem x u -> mem (f @ x) (map f u) ])

natural_def11 ::= (not (mem 0 bnatural1)) ([ not 
  mem 0 bnatural1 ])

boolset_def1 ::= ((mem ^bool boolean)) ([ forall x:
                                                                 bool.
                                                                 mem
                                                                  x boolean ])

id_def1 ::= ((<-> (mem (^'a, ^'a) id) (= ^'a ^'a))) ([ 
  forall x:'a, y:'a. mem (x, y) (id:set ('a, 'a)) <-> x = y ])

prj1_def1 ::= ((<-> (mem ((^'a, ^'b), ^'a) prj1) (= ^'a ^'a))) ([ 
  forall x:'a, z:'a, y:'b.
   mem ((x, y), z) (prj1:set (('a, 'b), 'a)) <-> x = z ])

prj1_def2 ::= (= (image prj1 (singleton (1, (2, 3)))) (singleton 1)) ([ 
  image (prj1:set ((int, (int, int)), int)) (singleton (1, (2, 3))) =
   singleton 1 ])

prj2_def1 ::= ((<-> (mem ((^'a, ^'b), ^'b) prj2) (= ^'b ^'b))) ([ 
  forall x:'a, y:'b, z:'b.
   mem ((x, y), z) (prj2:set (('a, 'b), 'b)) <-> y = z ])

unMinus_def1 ::= ((= (unMinus (unMinus ^int)) ^int)) ([ 
  forall x:int. unMinus (unMinus x) = x ])

unMinus_def2 ::= ((<-> (mem ^int integer) (mem (unMinus ^int) integer))) ([ 
  forall x:int. mem x integer <-> mem (unMinus x) integer ])

unMinus_def3 ::= ((-> (mem ^int natural) (not (mem (unMinus ^int) natural)))) ([ 
  forall x:int. mem x natural -> not mem (unMinus x) natural ])

Power_0 ::= ((= (power ^int 0) one)) ([ 
  forall x:int. power x 0 = one ])

Power_s ::= ((-> (>= ^int 0) (= (power ^int (+ ^int 1)) (* ^int (power ^int ^int))))) ([ 
  forall x:int, n:int. n >= 0 -> power x (n + 1) = (x * power x n) ])

Power_s_alt ::= ((-> (> ^int 0) (= (power ^int ^int) (* ^int (power ^int (- ^int 1)))))) ([ 
  forall x:int, n:int. n > 0 -> power x n = (x * power x (n - 1)) ])

Power_1 ::= ((= (power ^int 1) ^int)) ([ 
  forall x:int. power x 1 = x ])

Power_sum ::= ((-> (<= 0 ^int) (-> (<= 0 ^int) (= (power ^int (+ ^int ^int)) (* (power ^int ^int) (power ^int ^int)))))) ([ 
  forall x:int, n:int, m:int.
   0 <= n -> 0 <= m -> power x (n + m) = (power x n * power x m) ])

Power_mult ::= ((-> (<= 0 ^int) (-> (<= 0 ^int) (= (power ^int (* ^int ^int)) (power (power ^int ^int) ^int))))) ([ 
  forall x:int, n:int, m:int.
   0 <= n -> 0 <= m -> power x (n * m) = power (power x n) m ])

Power_mult2 ::= ((-> (<= 0 ^int) (= (power (* ^int ^int) ^int) (* (power ^int ^int) (power ^int ^int))))) ([ 
  forall x:int, y:int, n:int.
   0 <= n -> power (x * y) n = (power x n * power y n) ])

lemma_Mod_1 ::= ((= (mod ^int 1) 0)) ([ 
  forall x:int. mod x 1 = 0 ])

lemma_Div_1 ::= ((= (div ^int 1) ^int)) ([ 
  forall x:int. div x 1 = x ])

lemma_Div_inf ::= ((-> (/\ (<= 0 ^int) (< ^int ^int)) (= (div ^int ^int) 0))) ([ 
  forall x:int, y:int. 0 <= x /\ x < y -> div x y = 0 ])

lemma_Div_inf_neg ::= ((-> (/\ (< 0 ^int) (<= ^int ^int)) (= (div (- ^int) ^int) (- 1)))) ([ 
  forall x:int, y:int. 0 < x /\ x <= y -> div (- x) y = (- 1) ])

lemma_Mod_0 ::= ((-> (not (= ^int 0)) (= (mod 0 ^int) 0))) ([ 
  forall y:int. not y = 0 -> mod 0 y = 0 ])

lemma_Div_1_left ::= ((-> (> ^int 1) (= (div 1 ^int) 0))) ([ 
  forall y:int. y > 1 -> div 1 y = 0 ])

lemma_Div_minus1_left ::= ((-> (> ^int 1) (= (div (- 1) ^int) (- 1)))) ([ 
  forall y:int. y > 1 -> div (- 1) y = (- 1) ])

lemma_Mod_1_left ::= ((-> (> ^int 1) (= (mod 1 ^int) 1))) ([ 
  forall y:int. y > 1 -> mod 1 y = 1 ])

lemma_Mod_minus1_left ::= ((-> (> ^int 1) (= (mod (- 1) ^int) (- ^int 1)))) ([ 
  forall y:int. y > 1 -> mod (- 1) y = (y - 1) ])

lemma_Div_mult ::= ((-> (> ^int 0) (= (div (+ (* ^int ^int) ^int) ^int) (+ ^int (div ^int ^int))))) ([ 
  forall x:int, y:int, z:int [div ((x * y) + z) x].
   x > 0 -> div ((x * y) + z) x = (y + div z x) ])

lemma_Mod_mult ::= ((-> (> ^int 0) (= (mod (+ (* ^int ^int) ^int) ^int) (mod ^int ^int)))) ([ 
  forall x:int, y:int, z:int [mod ((x * y) + z) x].
   x > 0 -> mod ((x * y) + z) x = mod z x ])

lemma_difference_def2 ::= ((subset (diff ^(set 'a) ^(set 'a)) ^(set 'a))) ([ 
  forall s1:set 'a, s2:set 'a. subset (diff s1 s2) s1 ])

lemma_image_def2 ::= ((= (image ^(set (, 'a 'b)) (union ^(set 'a) ^(set 'a))) (union (image ^(set (, 'a 'b)) ^(set 'a)) (image ^(set (, 'a 'b)) ^(set 'a))))) ([ 
  forall r:set ('a, 'b), s:set 'a, t:set 'a.
   image r (union s t) = union (image r s) (image r t) ])

lemma_image_def3 ::= ((= (image ^(set (, 'a 'b)) (add ^'a ^(set 'a))) (union (image ^(set (, 'a 'b)) (singleton ^'a)) (image ^(set (, 'a 'b)) ^(set 'a))))) ([ 
  forall r:set ('a, 'b), dom1:set 'a, x:'a.
   image r (add x dom1) = union (image r (singleton x)) (image r dom1) ])

lemma_partialfunction_def4 ::= ((-> (subset ^(set 'b) ^(set 'b)) (-> (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b)))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b, u:set 'b.
   subset t u -> mem f (s +-> t) -> mem f (s +-> u) ])

lemma_partialfunction_def5 ::= ((-> (subset ^(set 'b) ^(set 'b)) (-> (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))) (-> ((-> (mem (^'a, ^'b) ^(set (, 'a 'b))) (mem ^'b ^(set 'b)))) (mem ^(set (, 'a 'b)) (+-> ^(set 'a) ^(set 'b))))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b, u:set 'b.
   subset u t ->
    mem f (s +-> t) ->
     (forall x:'a, y:'b. mem (x, y) f -> mem y u) -> mem f (s +-> u) ])

lemma_tf0 ::= ((-> (/\ (mem ^(set (, 'a 'b)) (--> ^(set 'a) ^(set 'b))) (/\ (mem ^'a ^(set 'a)) (mem ^'b ^(set 'b)))) (mem (<+ ^(set (, 'a 'b)) (singleton (^'a, ^'b))) (--> ^(set 'a) ^(set 'b))))) ([ 
  forall f:set ('a, 'b), s:set 'a, t:set 'b, x:'a, y:'b.
   mem f (s --> t) /\ mem x s /\ mem y t ->
    mem (f <+ singleton (x, y)) (s --> t) ])

lemma_cprod_def3 ::= ((<-> (mem (^'a, ^'b) (cprod ^(set 'a) (inter ^(set 'b) ^(set 'b)))) (mem (^'a, ^'b) (inter (cprod ^(set 'a) ^(set 'b)) (cprod ^(set 'a) ^(set 'b)))))) ([ 
  forall x:'a, y:'b, s:set 'a, t:set 'b, r:set 'b.
   mem (x, y) (cprod s (inter t r)) <->
    mem (x, y) (inter (cprod s t) (cprod s r)) ])

lemma_cprod_def4 ::= ((-> (subset ^(set 'a) ^(set 'a)) (subset (cprod ^(set 'a) ^(set 'b)) (cprod ^(set 'a) ^(set 'b))))) ([ 
  forall s:set 'a, t:set 'a, r:set 'b.
   subset s t -> subset (cprod s r) (cprod t r) ])

dprod_def2 ::= ((-> (mem ^'a (dom (dprod ^(set (, 'a 'b)) ^(set (, 'a 'c))))) (mem ^'a (union (dom ^(set (, 'a 'b))) (dom ^(set (, 'a 'c))))))) ([ 
  forall s:set ('a, 'b), t:set ('a, 'c), x:'a.
   mem x (dom (dprod s t)) -> mem x (union (dom s) (dom t)) ])

lemma_fcomp_def2 ::= ((subset (dom (fcomp ^(set (, 'a 'b)) ^(set (, 'b 'c)))) (dom ^(set (, 'a 'b))))) ([ 
  forall f:set ('a, 'b), g:set ('b, 'c). subset (dom (fcomp f g)) (dom f) ])

lemma_fcomp_def3 ::= ((subset (ran (fcomp ^(set (, 'a 'b)) ^(set (, 'b 'c)))) (ran ^(set (, 'b 'c))))) ([ 
  forall f:set ('a, 'b), g:set ('b, 'c). subset (ran (fcomp f g)) (ran g) ])

lemma_fcomp_def4 ::= ((-> (= (inter (ran ^(set (, 'a 'b))) (dom ^(set (, 'b 'c)))) empty) (= (fcomp ^(set (, 'a 'b)) ^(set (, 'b 'c))) empty))) ([ 
  forall f:set ('a, 'b), g:set ('b, 'c).
   inter (ran f) (dom g) = (empty:set 'b) -> fcomp f g = (empty:set ('a, 'c)) ])

lemma_finite_def4 ::= ((-> (finite ^(set 'a)) (finite (add ^'a ^(set 'a))))) ([ 
  forall s:set 'a, x:'a. finite s -> finite (add x s) ])

lemma_finite_def5 ::= ((-> ((/\ (mem ^(set (, 'a 'b)) (>->> ^(set 'a) ^(set 'b))) (finite ^(set 'b)))) (finite ^(set 'a)))) ([ 
  forall s:set 'a, t:set 'b.
   (exists f:set ('a, 'b). mem f (s >->> t) /\ finite t) -> finite s ])

lemma_min_def4 ::= ((-> (finite ^(set int)) (-> (> ^int ^int) (= (min (add ^int (singleton ^int))) ^int)))) ([ 
  forall s:set int, x:int, y:int.
   finite s -> y > x -> min (add y (singleton x)) = x ])

lemma_max_def4 ::= ((-> (finite ^(set int)) (-> (> ^int ^int) (= (max (add ^int (singleton ^int))) ^int)))) ([ 
  forall s:set int, x:int, y:int.
   finite s -> y > x -> max (add y (singleton x)) = y ])

lemma_card_def5 ::= ((-> (/\ (finite ^(set 'a)) ((-> (mem ^'a ^(set 'a)) (mem ^'a ^(set 'a))))) (<= (card ^(set 'a)) (card ^(set 'a))))) ([ 
  forall s:set 'a, t:set 'a.
   finite t /\ (forall x:'a. mem x s -> mem x t) -> card s <= card t ])

lemma_card_def6 ::= ((-> (/\ (finite ^(set 'a)) ((-> (mem ^'a ^(set 'a)) (mem ^'a ^(set 'a))))) (subset ^(set 'a) ^(set 'a)))) ([ 
  forall s:set 'a, t:set 'a.
   finite t /\ (forall x:'a. mem x s -> mem x t) -> subset s t ])

lemma_card_def7 ::= ((-> (/\ (finite ^(set 'a)) (subset ^(set 'a) ^(set 'a))) (<= (card ^(set 'a)) (card ^(set 'a))))) ([ 
  forall s:set 'a, t:set 'a. finite t /\ subset s t -> card s <= card t ])

lemma_card_def8 ::= ((-> (/\ (finite ^(set 'a)) (/\ ((-> (mem ^'a ^(set 'a)) (mem ^'a ^(set 'a)))) ((/\ (not (mem ^'a ^(set 'a))) (mem ^'a ^(set 'a)))))) (< (card ^(set 'a)) (card ^(set 'a))))) ([ 
  forall s:set 'a, t:set 'a.
   finite t /\
    (forall x:'a. mem x s -> mem x t) /\
     (exists b:'a. not mem b s /\ mem b t) -> card s < card t ])

lemma_card_def9 ::= ((-> (/\ (finite ^(set 'a)) (subsetprop ^(set 'a) ^(set 'a))) (< (card ^(set 'a)) (card ^(set 'a))))) ([ 
  forall s:set 'a, t:set 'a. finite t /\ subsetprop s t -> card s < card t ])

lemma_card_def10 ::= ((-> (/\ (finite ^(set 'b)) (mem ^(set (, 'a 'b)) (>->> ^(set 'a) ^(set 'b)))) (= (card ^(set 'a)) (card ^(set 'b))))) ([ 
  forall s:set 'a, t:set 'b, f:set ('a, 'b).
   finite t /\ mem f (s >->> t) -> card s = card t ])

lemma_card_def11 ::= ((-> (/\ (mem ^(set (, 'a 'b)) (>-> ^(set 'a) ^(set 'b))) (mem ^(set (, 'b 'a)) (>-> ^(set 'b) ^(set 'a)))) ((mem ^(set (, 'a 'b)) (>->> ^(set 'a) ^(set 'b)))))) ([ 
  forall s:set 'a, t:set 'b, f:set ('a, 'b), g:set ('b, 'a).
   mem f (s >-> t) /\ mem g (t >-> s) ->
    (exists h:set ('a, 'b). mem h (s >->> t)) ])

lemma_card_def12 ::= ((-> (/\ (= (card ^(set 'a)) (card ^(set 'b))) (mem ^(set (, 'a 'b)) (>-> ^(set 'a) ^(set 'b)))) (mem ^(set (, 'a 'b)) (-->> ^(set 'a) ^(set 'b))))) ([ 
  forall s:set 'a, t:set 'b, f:set ('a, 'b).
   card s = card t /\ mem f (s >-> t) -> mem f (s -->> t) ])

lemma_card_def13 ::= ((-> (is_empty ^(set 'a)) (= (card (cprod ^(set 'a) ^(set 'a))) 0))) ([ 
  forall s:set 'a, t:set 'a. is_empty t -> card (cprod t s) = 0 ])

lemma_card_def14 ::= ((= (card (cprod (singleton ^'a) ^(set 'a))) (card ^(set 'a)))) ([ 
  forall s:set 'a, x:'a. card (cprod (singleton x) s) = card s ])

lemma_card_def15 ::= ((-> (not (mem ^'a ^(set 'a))) (= (card (cprod (union ^(set 'a) (singleton ^'a)) ^(set 'a))) (+ (card (cprod ^(set 'a) ^(set 'a))) (card ^(set 'a)))))) ([ 
  forall s:set 'a, t:set 'a, x:'a.
   not mem x s ->
    card (cprod (union s (singleton x)) t) = (card (cprod s t) + card t) ])

lemma_card_def16 ::= ((= (card (cprod ^(set 'a) ^(set 'b))) (* (card ^(set 'a)) (card ^(set 'b))))) ([ 
  forall s:set 'a, t:set 'b. card (cprod s t) = (card s * card t) ])

lemma_domRes_def3 ::= ((-> ((-> (mem (^'a, ^'b) (<| ^(set 'a) ^(set (, 'a 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) (subset (<| ^(set 'a) ^(set (, 'a 'b))) ^(set (, 'a 'b))))) ([ 
  forall s:set 'a, r:set ('a, 'b).
   (forall x:'a, y:'b. mem (x, y) (s <| r) -> mem (x, y) r) ->
    subset (s <| r) r ])

lemma_domRes_def5 ::= ((-> (mem (^'a, ^'b) (<| (dom ^(set (, 'a 'b))) ^(set (, 'a 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall r:set ('a, 'b), x:'a, y:'b. mem (x, y) (dom r <| r) -> mem (x, y) r ])

lemma_domRes_def6 ::= ((<-> (mem (^'a, ^'b) (<| empty ^(set (, 'a 'b)))) (mem (^'a, ^'b) empty))) ([ 
  forall r:set ('a, 'b), x:'a, y:'b.
   mem (x, y) ((empty:set 'a) <| r) <-> mem (x, y) (empty:set ('a, 'b)) ])

lemma_domSub_def2 ::= ((-> (mem (^'a, ^'b) (union (<| ^(set 'a) ^(set (, 'a 'b))) (<<| ^(set 'a) ^(set (, 'a 'b))))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall x:'a, y:'b, s:set 'a, r:set ('a, 'b).
   mem (x, y) (union (s <| r) (s <<| r)) -> mem (x, y) r ])

lemma_domSub_def3 ::= ((<-> (mem (^'a, ^'b) (inter (<| ^(set 'a) ^(set (, 'a 'b))) (<<| ^(set 'a) ^(set (, 'a 'b))))) (mem (^'a, ^'b) empty))) ([ 
  forall x:'a, y:'b, s:set 'a, r:set ('a, 'b).
   mem (x, y) (inter (s <| r) (s <<| r)) <-> mem (x, y) (empty:set ('a, 'b)) ])

lemma_domSub_def4 ::= ((-> (mem (^'a, ^'b) (<<| empty ^(set (, 'a 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall x:'a, y:'b, r:set ('a, 'b).
   mem (x, y) ((empty:set 'a) <<| r) -> mem (x, y) r ])

lemma_ranRes_def2 ::= ((-> (mem (^'a, ^'b) (|> ^(set (, 'a 'b)) (ran ^(set (, 'a 'b))))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall r:set ('a, 'b), x:'a, y:'b. mem (x, y) (r |> ran r) -> mem (x, y) r ])

lemma_ranRes_def3 ::= ((subset (|> ^(set (, 'a 'b)) ^(set 'b)) ^(set (, 'a 'b)))) ([ 
  forall r:set ('a, 'b), t:set 'b. subset (r |> t) r ])

lemma_rangesub_def2 ::= ((-> (mem (^'a, ^'b) (union (|> ^(set (, 'a 'b)) ^(set 'b)) (|>> ^(set (, 'a 'b)) ^(set 'b)))) (mem (^'a, ^'b) ^(set (, 'a 'b))))) ([ 
  forall x:'a, y:'b, t:set 'b, r:set ('a, 'b).
   mem (x, y) (union (r |> t) (r |>> t)) -> mem (x, y) r ])

lemma_over_def3 ::= ((-> (mem ^'b (image (<+ ^(set (, 'a 'b)) ^(set (, 'a 'b))) (dom (<+ ^(set (, 'a 'b)) ^(set (, 'a 'b)))))) (mem ^'b (union (ran ^(set (, 'a 'b))) (ran ^(set (, 'a 'b))))))) ([ 
  forall r:set ('a, 'b), g:set ('a, 'b), y:'b.
   mem y (image (r <+ g) (dom (r <+ g))) -> mem y (union (ran r) (ran g)) ])

lemma_natural_def8 ::= (subsetprop bnatural1 natural) ([ 
  subsetprop bnatural1 natural ])


end
